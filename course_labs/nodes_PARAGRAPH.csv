uid;name;span;source;code;summary
"PARAGRAPH:::CBLDB22:::GET-ALL";"GET-ALL";"9181:10205";"/cbl/CBLDB22.cbl";"       GET-ALL.                                                         \n                EXEC SQL OPEN CUR1  END-EXEC.                           \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'OPEN CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL FETCH CUR1  INTO :CUSTOMER-RECORD END-EXEC.    \n                PERFORM PRINT-ALL                                    \n                     UNTIL SQLCODE IS NOT EQUAL TO ZERO.                \n                IF SQLCODE NOT = 100 THEN\n                   MOVE 'FETCH CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL CLOSE CUR1  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'CLOSE CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                .\n                                                                        ";"This paragraph retrieves all customer records from a database using a cursor. It opens a cursor named `CUR1`, then repeatedly fetches records into `CUSTOMER-RECORD` until no more records are found. After fetching, it closes the cursor. Error handling is performed after each database operation (open, fetch, close) by checking `SQLCODE` and calling `SQL-ERROR-HANDLING` if an error occurs."
"PARAGRAPH:::CBLDB22:::GET-SPECIFIC";"GET-SPECIFIC";"10498:11522";"/cbl/CBLDB22.cbl";"       GET-SPECIFIC.                                                    \n                EXEC SQL OPEN  CUR2  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'OPEN CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL FETCH CUR2  INTO :CUSTOMER-RECORD END-EXEC.    \n                PERFORM PRINT-SPECIFIC                               \n                     UNTIL SQLCODE IS NOT EQUAL TO ZERO.                \n                IF SQLCODE NOT = 100 THEN\n                   MOVE 'FETCH CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL CLOSE CUR2  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'CLOSE CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                .\n                                                                        ";"This paragraph is responsible for accessing specific data from a database using a cursor.\n\nIt first opens a database cursor named `CUR2`. It then performs an initial fetch of data into the `CUSTOMER-RECORD` variable. Following this, it repeatedly calls the `PRINT-SPECIFIC` routine, presumably to process or display fetched records, until no more records are found or an error occurs. Finally, it closes the cursor. Error handling is integrated throughout, checking the SQL status after each database operation (open, fetch, close) and calling an error routine if any issues arise."
"PARAGRAPH:::CBLDB22:::PRINT-A-LINE";"PRINT-A-LINE";"11815:12405";"/cbl/CBLDB22.cbl";"       PRINT-A-LINE.                                                    \n                MOVE  ACCT-NO      TO  ACCT-NO-O.                       \n                MOVE  ACCT-LIMIT   TO  ACCT-LIMIT-O.                    \n                MOVE  ACCT-BALANCE TO  ACCT-BALANCE-O.                  \n                MOVE  ACCT-LASTN   TO  ACCT-LASTN-O.                    \n                MOVE  ACCT-FIRSTN  TO  ACCT-FIRSTN-O.                   \n                MOVE  ACCT-COMMENT TO  ACCT-COMMENT-O.                  \n                WRITE REPREC AFTER ADVANCING 2 LINES.                   \n      ";"This paragraph prepares account-related data for output by moving various account details (account number, limit, balance, last name, first name, and comment) to corresponding output fields. After preparing the data, it writes a record to a file or printer, advancing two lines before printing."
"PARAGRAPH:::CBLDB22:::PRINT-ALL";"PRINT-ALL";"10206:10497";"/cbl/CBLDB22.cbl";"       PRINT-ALL.                                                       \n                PERFORM PRINT-A-LINE.                                   \n                EXEC SQL FETCH CUR1  INTO :CUSTOMER-RECORD END-EXEC.    \n                                                                        ";"This paragraph first calls another routine to print a line. Afterwards, it retrieves the next available record from a database cursor named `CUR1` and stores this data into the `CUSTOMER-RECORD` variable."
"PARAGRAPH:::CBLDB22:::PRINT-SPECIFIC";"PRINT-SPECIFIC";"11523:11814";"/cbl/CBLDB22.cbl";"       PRINT-SPECIFIC.                                                  \n                PERFORM PRINT-A-LINE.                                   \n                EXEC SQL FETCH CUR2  INTO :CUSTOMER-RECORD END-EXEC.    \n                                                                        ";"This paragraph first executes another paragraph named `PRINT-A-LINE`. Afterwards, it fetches a record from a database using a cursor named `CUR2` and stores the retrieved data into the `CUSTOMER-RECORD` variable."
"PARAGRAPH:::CBLDB22:::PROCESS-INPUT";"PROCESS-INPUT";"8618:9180";"/cbl/CBLDB22.cbl";"       PROCESS-INPUT.                                                   \n                IF LNAME = '*'                                          \n                   PERFORM GET-ALL                                      \n                ELSE                                                    \n                   PERFORM GET-SPECIFIC.                                \n                READ RECIN  RECORD INTO IOAREA                          \n                   AT END SET NOMORE-INPUT TO TRUE.\n                                                                        ";"This paragraph first checks if the `LNAME` variable contains an asterisk (`'*'`). If it does, it executes the `GET-ALL` routine; otherwise, it executes the `GET-SPECIFIC` routine. Following this, it reads a record from the `RECIN` file into the `IOAREA` and sets a flag (`NOMORE-INPUT`) if it reaches the end of the file."
"PARAGRAPH:::CBLDB22:::PROG-END";"PROG-END";"8253:8617";"/cbl/CBLDB22.cbl";"       PROG-END.                                                        \n                CLOSE RECIN                                             \n                      REPOUT.                                           \n                GOBACK.                                                 \n                                                                        ";"This paragraph is responsible for closing the input file `RECIN` and the output report file `REPOUT`. After closing the files, it terminates the program and returns control to the calling program or system."
"PARAGRAPH:::CBLDB22:::PROG-START";"PROG-START";"7690:8252";"/cbl/CBLDB22.cbl";"       PROG-START.                                                      \n                OPEN INPUT  RECIN.                                      \n                OPEN OUTPUT REPOUT.                                     \n                READ RECIN  RECORD INTO IOAREA                          \n                   AT END SET NOMORE-INPUT TO TRUE.\n                PERFORM PROCESS-INPUT                                   \n                   UNTIL NOMORE-INPUT.                                  \n                                                                        ";"This paragraph initializes the program's main processing loop. It opens the input file `RECIN` and the output file `REPOUT`. It then reads the very first record from `RECIN` into `IOAREA`, setting a flag if no records are found. Finally, it repeatedly executes the `PROCESS-INPUT` paragraph until all records from the input file have been processed."
"PARAGRAPH:::CBLDB22:::SQL-ERROR-HANDLING";"SQL-ERROR-HANDLING";"12406:12983";"/cbl/CBLDB22.cbl";"       SQL-ERROR-HANDLING.\n           DISPLAY 'ERROR AT ' FUNCTION TRIM(UD-ERROR-MESSAGE, TRAILING)\n           CALL 'DSNTIAR' USING SQLCA ERROR-MESSAGE ERROR-TEXT-LEN.\n           PERFORM VARYING ERROR-INDEX FROM 1 BY 1\n                     UNTIL ERROR-INDEX > ERROR-TEXT-HBOUND\n                        OR ERROR-TEXT(ERROR-INDEX) = SPACES\n              DISPLAY FUNCTION TRIM(ERROR-TEXT(ERROR-INDEX), TRAILING)\n           END-PERFORM\n           IF SQLCODE NOT = 0 AND SQLCODE NOT = 100\n              MOVE 1000 TO RETURN-CODE\n              STOP RUN\n           END-IF\n           .\n";"This COBOL paragraph, `SQL-ERROR-HANDLING`, is designed to process and display information related to SQL errors. It first displays a general error message, then calls a DB2 utility to retrieve more detailed SQL error text. This detailed error text is then displayed line by line. Finally, if a significant SQL error (other than a successful or \"not found\" status) has occurred, the program sets a return code and terminates execution."
"PARAGRAPH:::CBLDB22:::__unnamed_paragraph__";"__unnamed_paragraph__";"7471:7690";"/cbl/CBLDB22.cbl";"                                                                        \n       PROCEDURE DIVISION.                                              \n                                                                        \n";"This code snippet marks the beginning of the program's `PROCEDURE DIVISION`, which is where the main executable logic of the COBOL program is defined."
"PARAGRAPH:::CBLDB23:::GET-ALL";"GET-ALL";"8670:9621";"/cbl/CBLDB23.cbl";"       GET-ALL.                                                         \n                EXEC SQL OPEN CUR1  END-EXEC.                           \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'OPEN CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL FETCH CUR1  INTO :CUSTOMER-RECORD END-EXEC.    \n                PERFORM PRINT-ALL                                    \n                     UNTIL SQLCODE IS NOT EQUAL TO ZERO.                \n                IF SQLCODE NOT = 100 THEN\n                   MOVE 'FETCH CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL CLOSE CUR1  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'CLOSE CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                .";"This paragraph is responsible for retrieving and processing all records from a database cursor named `CUR1`. It first opens the cursor, then iteratively fetches each record into `CUSTOMER-RECORD` and calls `PRINT-ALL` to process it, continuing until all records have been retrieved. Finally, it closes the cursor. Throughout the process, it includes error checking after each database operation (open, fetch, close) and invokes a `SQL-ERROR-HANDLING` routine if any errors occur."
"PARAGRAPH:::CBLDB23:::GET-SPECIFIC";"GET-SPECIFIC";"9841:10792";"/cbl/CBLDB23.cbl";"       GET-SPECIFIC.                                                    \n                EXEC SQL OPEN  CUR2  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'OPEN CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL FETCH CUR2  INTO :CUSTOMER-RECORD END-EXEC.    \n                PERFORM PRINT-SPECIFIC                               \n                     UNTIL SQLCODE IS NOT EQUAL TO ZERO.                \n                IF SQLCODE NOT = 100 THEN\n                   MOVE 'FETCH CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL CLOSE CUR2  END-EXEC.                          \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'CLOSE CUR2' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                .";"This paragraph is responsible for interacting with a database cursor named `CUR2`. It first opens the cursor, handling any errors that might occur during the opening process. Then, it fetches the first record from the cursor into a `CUSTOMER-RECORD` variable and proceeds to process (presumably print) subsequent records by repeatedly calling the `PRINT-SPECIFIC` routine until no more records are available or an error is encountered. Finally, it closes the cursor, again checking for and handling any errors during the closing operation."
"PARAGRAPH:::CBLDB23:::PRINT-A-LINE";"PRINT-A-LINE";"11012:11450";"/cbl/CBLDB23.cbl";"       PRINT-A-LINE.                                                    \n                MOVE  ACCT-NO      TO  ACCT-NO-O.                       \n                MOVE  ACCT-LASTN   TO  ACCT-LASTN-O.                    \n                MOVE  ACCT-FIRSTN  TO  ACCT-FIRSTN-O.                   \n                MOVE  ACCT-ADDR3   TO  ACCT-ADDR3-O.                    \n                WRITE REPREC AFTER ADVANCING 2 LINES.                   \n";"This paragraph prepares and prints a line of account information. It moves specific account details (account number, last name, first name, and a portion of the address) from input fields to their corresponding output fields, then writes the formatted record to an output file, advancing two lines before printing."
"PARAGRAPH:::CBLDB23:::PRINT-ALL";"PRINT-ALL";"9622:9840";"/cbl/CBLDB23.cbl";"       PRINT-ALL.                                                       \n                PERFORM PRINT-A-LINE.                                   \n                EXEC SQL FETCH CUR1  INTO :CUSTOMER-RECORD END-EXEC.    ";"This paragraph (`PRINT-ALL`) first performs a routine to print a line. Afterwards, it fetches the next record from the database using cursor `CUR1` and stores the data into the `CUSTOMER-RECORD` variable."
"PARAGRAPH:::CBLDB23:::PRINT-SPECIFIC";"PRINT-SPECIFIC";"10793:11011";"/cbl/CBLDB23.cbl";"       PRINT-SPECIFIC.                                                  \n                PERFORM PRINT-A-LINE.                                   \n                EXEC SQL FETCH CUR2  INTO :CUSTOMER-RECORD END-EXEC.    ";"This paragraph first executes the `PRINT-A-LINE` routine and then attempts to retrieve a single row of data into the `CUSTOMER-RECORD` variable from the database using the previously defined `CUR2` cursor."
"PARAGRAPH:::CBLDB23:::PROCESS-INPUT";"PROCESS-INPUT";"8180:8669";"/cbl/CBLDB23.cbl";"       PROCESS-INPUT.                                                   \n                IF STATE = '*'                                          \n                   PERFORM GET-ALL                                      \n                ELSE                                                    \n                   PERFORM GET-SPECIFIC.                                \n                READ CARDIN RECORD INTO IOAREA                          \n                   AT END SET NOMORE-INPUT TO TRUE.";"This paragraph, `PROCESS-INPUT`, determines how to retrieve data based on the value of a `STATE` variable. If `STATE` is an asterisk (`'*'`), it performs a routine to get all data; otherwise, it performs a routine to get specific data. Following this, it reads a record from the `CARDIN` file into an `IOAREA` and sets a flag (`NOMORE-INPUT`) if the end of the file is reached."
"PARAGRAPH:::CBLDB23:::PROG-END";"PROG-END";"7888:8179";"/cbl/CBLDB23.cbl";"       PROG-END.                                                        \n                CLOSE CARDIN                                            \n                      REPOUT.                                           \n                GOBACK.                                                 ";"This paragraph (`PROG-END`) is responsible for the program's termination sequence. It closes two files, `CARDIN` and `REPOUT`, and then returns control to the calling program or the operating system."
"PARAGRAPH:::CBLDB23:::PROG-START";"PROG-START";"7398:7887";"/cbl/CBLDB23.cbl";"       PROG-START.                                                      \n                OPEN INPUT  CARDIN.                                     \n                OPEN OUTPUT REPOUT.                                     \n                READ CARDIN RECORD INTO IOAREA                          \n                   AT END SET NOMORE-INPUT TO TRUE.\n                PERFORM PROCESS-INPUT                                   \n                   UNTIL NOMORE-INPUT.                                  ";"This paragraph initializes the program by opening input and output files. It reads the first record from the input file and then continuously processes subsequent records until the end of the input file is reached."
"PARAGRAPH:::CBLDB23:::SQL-ERROR-HANDLING";"SQL-ERROR-HANDLING";"11451:12028";"/cbl/CBLDB23.cbl";"       SQL-ERROR-HANDLING.\n           DISPLAY 'ERROR AT ' FUNCTION TRIM(UD-ERROR-MESSAGE, TRAILING)\n           CALL 'DSNTIAR' USING SQLCA ERROR-MESSAGE ERROR-TEXT-LEN.\n           PERFORM VARYING ERROR-INDEX FROM 1 BY 1\n                     UNTIL ERROR-INDEX > ERROR-TEXT-HBOUND\n                        OR ERROR-TEXT(ERROR-INDEX) = SPACES\n              DISPLAY FUNCTION TRIM(ERROR-TEXT(ERROR-INDEX), TRAILING)\n           END-PERFORM\n           IF SQLCODE NOT = 0 AND SQLCODE NOT = 100\n              MOVE 1000 TO RETURN-CODE\n              STOP RUN\n           END-IF\n           .\n";"This paragraph handles SQL errors by first displaying a general error message. It then calls an external routine to retrieve detailed SQL error information and displays each line of that detailed error text. Finally, if the SQL error code indicates a significant issue (not success or not found), it sets a return code and terminates the program."
"PARAGRAPH:::CBLDB23:::__unnamed_paragraph__";"__unnamed_paragraph__";"7179:7398";"/cbl/CBLDB23.cbl";"                                                                        \n       PROCEDURE DIVISION.                                              \n                                                                        \n";"This code snippet marks the beginning of the `PROCEDURE DIVISION`, which is where the main executable logic and instructions of the COBOL program are defined."
"PARAGRAPH:::CBLDB21:::LIST-ALL";"LIST-ALL";"6960:7914";"/cbl/CBLDB21.cbl";"       LIST-ALL.                                                        \n                EXEC SQL OPEN CUR1 END-EXEC.                            \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'OPEN CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL FETCH CUR1 INTO :CUSTOMER-RECORD END-EXEC.     \n                PERFORM PRINT-AND-GET1                                  \n                     UNTIL SQLCODE IS NOT EQUAL TO ZERO.                \n                IF SQLCODE NOT = 100 THEN\n                   MOVE 'FETCH CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                EXEC SQL CLOSE CUR1   END-EXEC.                         \n                IF SQLCODE NOT = 0 THEN\n                   MOVE 'CLOSE CUR1' TO UD-ERROR-MESSAGE\n                   PERFORM SQL-ERROR-HANDLING\n                END-IF\n                .";"This COBOL paragraph, `LIST-ALL`, is responsible for retrieving and processing data from a database using a cursor. It first opens a cursor named `CUR1`, handles any potential errors during the open operation, then fetches the first record. It subsequently enters a loop to repeatedly fetch and process records by calling the `PRINT-AND-GET1` paragraph until no more records are available. After the loop, it checks for any unexpected errors during fetching. Finally, it closes the cursor `CUR1`, with error handling at each of these stages."
"PARAGRAPH:::CBLDB21:::PRINT-A-LINE";"PRINT-A-LINE";"8134:8724";"/cbl/CBLDB21.cbl";"       PRINT-A-LINE.                                                    \n                MOVE  ACCT-NO      TO  ACCT-NO-O.                       \n                MOVE  ACCT-LIMIT   TO  ACCT-LIMIT-O.                    \n                MOVE  ACCT-BALANCE TO  ACCT-BALANCE-O.                  \n                MOVE  ACCT-LASTN   TO  ACCT-LASTN-O.                    \n                MOVE  ACCT-FIRSTN  TO  ACCT-FIRSTN-O.                   \n                MOVE  ACCT-COMMENT TO  ACCT-COMMENT-O.                  \n                WRITE REPREC AFTER ADVANCING 2 LINES.                   \n      ";"This paragraph prepares and prints a line of account information. It moves various account details such as number, limit, balance, last name, first name, and comment from their source fields to corresponding output fields. Finally, it writes this formatted record to an output file, advancing two lines before printing."
"PARAGRAPH:::CBLDB21:::PRINT-AND-GET1";"PRINT-AND-GET1";"7915:8133";"/cbl/CBLDB21.cbl";"       PRINT-AND-GET1.                                                  \n                PERFORM PRINT-A-LINE.                                   \n                EXEC SQL FETCH CUR1 INTO :CUSTOMER-RECORD END-EXEC.     ";"This paragraph first calls another routine to print a line. Afterwards, it fetches a single customer record from a database cursor named `CUR1` into the `CUSTOMER-RECORD` variable."
"PARAGRAPH:::CBLDB21:::PROG-END";"PROG-END";"6522:6959";"/cbl/CBLDB21.cbl";"       PROG-END.                                                        \n                CLOSE REPOUT.                                           \n                GOBACK.                                                 \n                                                                        \n                                                                        \n                                                                        ";"This paragraph closes the file named `REPOUT` and then terminates the program's execution, returning control to the caller."
"PARAGRAPH:::CBLDB21:::PROG-START";"PROG-START";"6303:6521";"/cbl/CBLDB21.cbl";"       PROG-START.                                                      \n                OPEN OUTPUT REPOUT.                                     \n                PERFORM LIST-ALL.                                       ";"This paragraph, named `PROG-START`, serves as an initialization routine. It opens a file called `REPOUT` for writing output and then proceeds to execute another section of code labeled `LIST-ALL`."
"PARAGRAPH:::CBLDB21:::SQL-ERROR-HANDLING";"SQL-ERROR-HANDLING";"8725:9302";"/cbl/CBLDB21.cbl";"       SQL-ERROR-HANDLING.\n           DISPLAY 'ERROR AT ' FUNCTION TRIM(UD-ERROR-MESSAGE, TRAILING)\n           CALL 'DSNTIAR' USING SQLCA ERROR-MESSAGE ERROR-TEXT-LEN.\n           PERFORM VARYING ERROR-INDEX FROM 1 BY 1\n                     UNTIL ERROR-INDEX > ERROR-TEXT-HBOUND\n                        OR ERROR-TEXT(ERROR-INDEX) = SPACES\n              DISPLAY FUNCTION TRIM(ERROR-TEXT(ERROR-INDEX), TRAILING)\n           END-PERFORM\n           IF SQLCODE NOT = 0 AND SQLCODE NOT = 100\n              MOVE 1000 TO RETURN-CODE\n              STOP RUN\n           END-IF\n           .\n";"This paragraph handles SQL errors by displaying a generic error message, then calling a utility to retrieve and display more detailed SQL error information. If a severe SQL error is detected (SQLCODE is neither 0 nor 100), it sets a return code to indicate an error and terminates the program."
"PARAGRAPH:::CBLDB21:::__unnamed_paragraph__";"__unnamed_paragraph__";"5792:6303";"/cbl/CBLDB21.cbl";"                                                                        \n       PROCEDURE DIVISION.                                              \n                                                                        \n                                                                        \n                                                                        \n                                                                        \n                                                                        \n";"This COBOL code defines the `PROCEDURE DIVISION`, which is the section of a COBOL program where the main processing logic and executable statements are located."